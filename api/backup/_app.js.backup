// ============================================================
// API/APP.TS - BACKEND SEGURO PARA CASES E BATTLES (TypeScript)
// ============================================================
import { createClient } from '@supabase/supabase-js';
import { handleOpenCases } from './_caseopening.js';
import { applyCors, checkRateLimit, cleanupOldEntries, getIdentifier, logAudit, validateSessionAndFetchPlayerStats, logMoneyTransactionAsync, } from './_utils.js';
import { applyReferralCommissionForSpend } from './_referrals.js';
import dotenv from 'dotenv';
dotenv.config();
// ============================================================
// üîå SUPABASE CLIENT
// ============================================================
const supabase = createClient(process.env.SUPABASE_URL ?? '', process.env.SUPABASE_SERVICE_KEY ?? '');
// ============================================================
// üõ°Ô∏è RATE LIMITING
// ============================================================
const rateLimits = new Map();
let lastRateLimitCleanupAt = 0;
function maybeCleanupRateLimits() {
    const now = Date.now();
    if (now - lastRateLimitCleanupAt < 5 * 60_000)
        return;
    lastRateLimitCleanupAt = now;
    cleanupOldEntries(rateLimits, { maxIdleMs: 15 * 60_000 });
}
// ============================================================
// üìù LOGGING E AUDITORIA
// ============================================================
async function logAction(userId, action, details, req) {
    return logAudit(supabase, userId, action, details, req ?? undefined);
}
// ============================================================
// üí∞ FUN√á√ÉO UTILIT√ÅRIA CENTRALIZADA PARA ATUALIZAR SALDO
// ============================================================
/**
 * Atualiza saldo do jogador de forma at√¥mica e registra tudo
 */
async function updatePlayerBalance(userId, amount, reason, casesOpened = 0, req = null) {
    try {
        const { data: rpcResult, error: updateError } = (await supabase.rpc('update_player_money', {
            p_user_id: userId,
            p_money_change: amount,
            p_cases_opened: casesOpened,
        }));
        if (updateError) {
            if (updateError.message.includes('Insufficient funds')) {
                throw new Error('Insufficient funds');
            }
            if (updateError.code === '23514' || updateError.message.includes('constraint')) {
                throw new Error('Balance changed. Please try again.');
            }
            throw new Error('Failed to update balance');
        }
        if (!rpcResult || rpcResult.length === 0) {
            throw new Error('RPC returned no data');
        }
        const newBalance = rpcResult[0].new_money;
        // Registrar transa√ß√£o na nova estrutura otimizada (non-blocking)
        logMoneyTransactionAsync(supabase, userId, amount, reason, newBalance);
        // Registrar auditoria
        if (req) {
            logAction(userId, 'BALANCE_UPDATED', { amount, reason, newBalance }, req).catch(() => { });
        }
        if (amount > 0) {
            // Aguarda a cria√ß√£o do evento para que o painel de referrals veja imediatamente
            await applyReferralCommissionForSpend({
                supabase,
                spenderId: userId,
                amountSpent: amount,
                reason,
                source: 'app',
                req,
            });
        }
        return newBalance;
    }
    catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        console.error('üí• updatePlayerBalance error:', message);
        throw error;
    }
}
// ============================================================
// üîê VALIDA√á√ÉO DE SESS√ÉO MELHORADA
// ============================================================
async function validateSession(authToken, expectedUserId) {
    return validateSessionAndFetchPlayerStats(supabase, authToken, expectedUserId, { select: 'user_id' });
}
// ============================================================
// MAIN HANDLER (ROTEAMENTO SEGURO)
// ============================================================
export default async function handler(req, res) {
    // 1. CORS RESTRITO (safe when env missing)
    applyCors(req, res);
    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }
    if (req.method !== 'POST') {
        res.status(405).json({ error: 'Method not allowed' });
        return;
    }
    const { action, userId, authToken } = req.body ?? {};
    maybeCleanupRateLimits();
    // 2. RATE LIMITING
    const identifier = getIdentifier(req, userId);
    const maxRequests = parseInt(process.env.RATE_LIMIT_MAX_REQUESTS ?? '0', 10) || 30;
    const windowMs = parseInt(process.env.RATE_LIMIT_WINDOW_MS ?? '0', 10) || 60_000;
    if (!checkRateLimit(rateLimits, identifier, { maxRequests, windowMs })) {
        logAction(userId ?? 'unknown', 'RATE_LIMIT_EXCEEDED', { action }, req).catch(() => { });
        res.status(429).json({ error: 'Too many requests. Please wait.' });
        return;
    }
    // 3. VALIDA√á√ÉO B√ÅSICA
    if (!action || typeof action !== 'string') {
        res.status(400).json({ error: 'Invalid action' });
        return;
    }
    if (!userId || typeof userId !== 'string') {
        res.status(400).json({ error: 'Invalid userId' });
        return;
    }
    if (!authToken || typeof authToken !== 'string') {
        res.status(400).json({ error: 'Invalid authToken' });
        return;
    }
    // 4. VALIDA√á√ÉO DE SESS√ÉO
    const { valid, error: sessionError } = await validateSession(authToken, userId);
    if (!valid) {
        logAction(userId, 'AUTH_FAILED', { action, error: sessionError }, req).catch(() => { });
        res.status(401).json({ error: sessionError });
        return;
    }
    // 5. ROTEAMENTO
    try {
        switch (action) {
            case 'openCases':
                await handleOpenCases(req, res);
                return;
            default:
                res.status(400).json({ error: 'Invalid action' });
                return;
        }
    }
    catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        console.error('Unhandled error:', message);
        logAction(userId, 'ERROR', { action, error: message }, req).catch(() => { });
        res.status(500).json({ error: 'Internal server error' });
    }
}
